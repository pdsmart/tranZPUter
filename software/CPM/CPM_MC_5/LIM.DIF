% File LIM.DIF	(c)		01/16/82	The Soft Warehouse %


FUNCTION QUERY (EX1, LEX1, LEX2, LEX3, READCHAR),
    % EX1: relative subexpression %
    % LEX1: query question %
    % LEX2: possible responses %
    % LEX3: AList of previous expressions & answers %
    % READCHAR: set to FALSE for raw input mode %
    % RSLT: dotted pair of response and revised AList %
  WHEN ASSOC(EX1,LEX3),
    ADJOIN (REST(ASSOC(EX1,LEX3)), LEX3) EXIT,
  NEWLINE (),
  PRINT ("???"), SPACES (2),
  PRTMATH (EX1, 0, 0, TRUE),
  SPACES (2), PRINTLINE ("???"),
  PRINT ('ENTER),
  LOOP
    SPACES (1),
    WHEN EMPTY (LEX1) EXIT,
    PRINT (POP(LEX1))
  ENDLOOP,
  PRINT (LEX2),
  PRINT ("? "),
  BLOCK
    WHEN BELL, PRINT ("") EXIT,
  ENDBLOCK,
  LOOP
    WHEN MEMBER (READCHAR(), LEX2) EXIT,
  ENDLOOP,
  PRINTLINE (SCAN),
  ADJOIN (SCAN, ADJOIN(ADJOIN(EX1,SCAN),LEX3))
ENDFUN $

FUNCTION SIGN(EX1),
  WHEN ZERO(EX1), EX1  EXIT,
  WHEN EX1 > 0,  1  EXIT,
  WHEN EX1 < 0, -1  EXIT,
  WHEN EX1 EQ PINF, 1  EXIT,
  WHEN EX1 EQ MINF, -1  EXIT,
  WHEN EX1 = PINF-MINF, 1  EXIT,
  EX1: QUERY (EX1, '(SIGN), LIST(0, '+, '-), SIGN),
  SIGN: REST(EX1),
  EX1: FIRST(EX1),
  WHEN ZERO(EX1), EX1 EXIT,
  WHEN EX1 EQ '+, 1 EXIT,
  -1
ENDFUN $

FUNCTION ODDEVEN (EX1),
  WHEN NUMBER (EX1),
    WHEN INTEGER (EX1),
      WHEN EVEN (EX1), 'E  EXIT,
      'O  EXIT EXIT,
  EX1: QUERY (EX1, '(ODD,EVEN,OR,NONINTEGER), '(O,E,N), ODDEVEN),
  ODDEVEN: REST(EX1),
  FIRST (EX1),
ENDFUN $

FUNCTION SIZE (EX1),
  WHEN ATOM(EX1), 1  EXIT,
  SIZE(POP(EX1)) + SIZE(EX1),
ENDFUN $


#LIM: 3 $

FUNCTION LIM1 (EX1, #LIM),
  % Fluid var from LIM:  INDET %
  WHEN EX1=INDET, PZERO  EXIT,
  WHEN ATOM(EX1), EX1  EXIT,
  WHEN APPLY (GET('LIM,FIRST(EX1)), ARGEX(EX1)), EXIT,
  LIST ('LIM, EX1, INDET, 0),
ENDFUN $

FUNCTION LIM (EX1,  % Optional: % INDET, EX2, EX3,
  % Local: % LOGBAS, PWREXPD, NUMNUM, DENDEN, DENNUM,
    NUMDEN, BASEXP, EXPBAS, LOGEXPD, TRGEXPD, SIGN, ODDEVEN),
  LOGBAS: #E,
  PWREXPD: NUMDEN: 0,
  NUMNUM: DENDEN: EXPBAS: 30,
  DENNUM: BASEXP: -30,
  LOGEXPD: 70,
  TRGEXPD: 2,
  BLOCK
    WHEN EX2, EXIT,
    EX2: 0
  ENDBLOCK,
  WHEN EX2 EQ PINF,  LIM1 (EVSUB(EX1,INDET,1/INDET), #LIM)  EXIT,
  WHEN EX2 EQ MINF,  LIM1 (EVSUB(EX1,INDET,-1/INDET), #LIM)  EXIT,
  WHEN EX3,  LIM1 (EVSUB(EX1,INDET,EX2-INDET), #LIM)  EXIT,
  WHEN INDET, LIM1 (EVSUB(EX1,INDET,EX2+INDET), #LIM), EXIT, LIM1(EX1,#LIM),
ENDFUN $

FUNCTION INDET (EX1, EX2,
  % Local: % EX3),
  % Fluid vars from LIM & LIM1:  #LIM, INDET %
  WHEN ZERO(#LIM), LIST ('LIM, EX1*EX2, INDET, 0)  EXIT,
  WHEN ATOM (EX3:DIF(EX1,INDET)/DIF(1/EX2,INDET)),
    LIM1 (EX3, #LIM-1)  EXIT,
  WHEN SIZE (EX1:DIF(EX2,INDET)/DIF(1/EX1,INDET)) < SIZE(EX3),
    LIM1 (EX1, #LIM-1)  EXIT,
  LIM1 (EX3, #LIM-1),
ENDFUN $


PROPERTY LIM, +, FUNCTION (
  % Local: % EX2, EX3, EX4, EX5, DENNUM),
  % Fluid vars from LIM & LIM1:  EX1, #LIM, INDET %
  DENNUM: -30,
  EX2: EX3: 0,
  LOOP
    WHEN ATOM (EX1:REST(EX1)),
      WHEN ZERO(EX2),
        WHEN ZERO(EX3), EX4  EXIT,
        MINF  EXIT,
      WHEN ZERO(EX3), PINF  EXIT,
      DENNUM: 0,
      WHEN MEMBER (EX5:INDET(1+EX3/EX2,EX2), '(? PINF MINF)),
          EX5  EXIT,
      WHEN EX5 EQ PZERO,
        WHEN EX4 EQ MZERO, 0  EXIT,
        WHEN EX4, EXIT,
        PZERO  EXIT,
      WHEN EX5 EQ MZERO,
        WHEN EX4 EQ PZERO, 0  EXIT,
        WHEN EX4, EXIT,
        MZERO  EXIT,
      WHEN MEMBER (EX4, '(FALSE PZERO MZERO)), EX5  EXIT,
      DENNUM: -30,
      EX4+EX5  EXIT,
    WHEN (EX5:LIM1(FIRST(EX1),#LIM)) EQ ?
        OR EX4 EQ CINF AND MEMBER(EX5,'(CINF,PINF,MINF))
        OR EX5 EQ CINF AND NOT(ZERO(EX2) AND ZERO(EX3)),  ?  EXIT,
    BLOCK
      WHEN EX5 EQ CINF, EX4:CINF  EXIT,
      WHEN EX5 EQ PINF, EX2: EX2+FIRST(EX1)  EXIT,
      WHEN EX5 EQ PZERO,
        WHEN EX4 EQ MZERO, EX4:0  EXIT,
        WHEN NOT EX4, EX4:PZERO  EXIT EXIT,
      WHEN EX5 EQ MZERO,
        WHEN EX4 EQ PZERO, EX4:0  EXIT,
        WHEN NOT EX4, EX4:MZERO  EXIT EXIT,
      WHEN EX5 EQ MINF, EX3: EX3+FIRST(EX1)  EXIT,
      WHEN MEMBER(EX4,'(FALSE PZERO MZERO)),  EX4:EX5  EXIT,
      EX4: EX4+EX5
    ENDBLOCK
  ENDLOOP,
ENDFUN $

PROPERTY LIM, *, FUNCTION (
  % Local: % EX2, EX3, EX4, EX5, EX6),
  % Fluid from LIM & LIM1:  EX1, #LIM, INDET %
  EX2: EX3: EX4: EX5: 1,
  LOOP
    WHEN ATOM (EX1:REST(EX1)),
      WHEN EX2 EQ 1,
        WHEN EX3 EQ 1, EX4  EXIT,
        WHEN POSITIVE (EX5:EX5*SIGN(EX4)), PZERO  EXIT,
        WHEN NEGATIVE(EX5), MZERO  EXIT,
        0  EXIT,
      WHEN EX3 EQ 1,
        WHEN POSITIVE (EX5:EX5*SIGN(EX4)), PINF  EXIT,
        WHEN NEGATIVE(EX5), MINF  EXIT,
        CINF  EXIT,
      WHEN (EX6:INDET(EX3,EX2)) EQ ?, ?  EXIT,
      WHEN MEMBER (EX6, '(CINF PINF PZERO MZERO MINF)),
        EX5: SIGN(EX4),
        WHEN EX6 EQ CINF,
          WHEN ZERO(EX5), ?  EXIT,
          CINF  EXIT,
        WHEN EX6 EQ PINF,
          WHEN POSITIVE(EX5), PINF  EXIT,
          WHEN NEGATIVE(EX5), MINF  EXIT,
          ?  EXIT,
        WHEN EX6 EQ PZERO,
          WHEN POSITIVE(EX5), PZERO  EXIT,
          WHEN NEGATIVE(EX5), MZERO  EXIT,
          0  EXIT,
        WHEN EX6 EQ MZERO,
          WHEN POSITIVE(EX5), MZERO  EXIT,
          WHEN NEGATIVE(EX5), PZERO  EXIT,
          0  EXIT,
        WHEN POSITIVE(EX5), MINF  EXIT,
        WHEN NEGATIVE(EX5), PINF  EXIT,
        ?  EXIT,
      EX4*EX6  EXIT,
    WHEN (EX6:LIM1(FIRST(EX1),#LIM)) EQ ?, ? EXIT,
    BLOCK
      WHEN EX6 EQ CINF, EX2: EX2*FIRST(EX1), EX5:0  EXIT,
      WHEN EX6 EQ PINF, EX2: EX2*FIRST(EX1)  EXIT,
      WHEN EX6 EQ PZERO, EX3: EX3*FIRST(EX1)  EXIT,
      WHEN EX6 EQ MZERO, EX3: EX3*FIRST(EX1), EX5:-EX5  EXIT,
      WHEN EX6 EQ MINF, EX2: EX2*FIRST(EX1), EX5:-EX5  EXIT,
      WHEN ZERO(EX6), EX3: EX3*FIRST(EX1), EX5:0  EXIT,
      EX4: EX4*EX6
    ENDBLOCK
  ENDLOOP,
ENDFUN $

PROPERTY LIM, ^, FUNCTION (EX1, EX2),
  % Fluid vars from LIM & LIM1:  #LIM, INDET %
  WHEN (EX1:LIM1(EX1,#LIM)) EQ 1, 1  EXIT,
  WHEN EX1 EQ ? OR MEMBER (EX2:LIM1(EX2,#LIM), '(? CINF)), ?  EXIT,
  WHEN MEMBER (EX2, '(PZERO 0 MZERO)),
    WHEN MEMBER (EX1, '(PZERO 0 MZERO)), ?  EXIT,
    1 EXIT,
  WHEN EX2 EQ PINF,
    WHEN MEMBER (EX1, '(CINF MINF)), CINF  EXIT,
    WHEN MEMBER (EX1, '(PINF PZERO)),  EX1  EXIT,
    WHEN EX1 EQ MZERO, 0  EXIT,
    WHEN EX1 EQ #E OR POSITIVE(EX2:SIGN(EX1-1)), PINF  EXIT,
    WHEN ZERO(EX2), 1  EXIT,
    WHEN POSITIVE(EX2:SIGN(EX1)), PZERO  EXIT,
    WHEN ZERO(EX2), 0  EXIT,
    WHEN POSITIVE (EX2:SIGN(EX1+1)), 0  EXIT,
    WHEN NEGATIVE(EX2), CINF  EXIT,
  ?  EXIT,
  WHEN EX2 EQ MINF,
    WHEN EX1 EQ PZERO, PINF  EXIT,
    WHEN EX1 EQ MZERO, CINF  EXIT,
    WHEN MEMBER (EX1, '(CINF MINF)), 0  EXIT,
    WHEN EX1 EQ PINF OR EX1 EQ #E OR POSITIVE(EX2:SIGN(EX1-1)), PZERO  EXIT,
    WHEN ZERO(EX2), 1 EXIT,
    WHEN POSITIVE (EX2:SIGN(EX1)), PINF  EXIT,
    WHEN ZERO(EX2), CINF  EXIT,
    WHEN NEGATIVE (EX2:SIGN(EX1+1)), 0  EXIT,
    WHEN POSITIVE(EX2), CINF  EXIT,
    ?  EXIT,
  WHEN EX1 EQ CINF,
    WHEN POSITIVE (EX2:SIGN(EX2)), CINF  EXIT,
    WHEN NEGATIVE(EX2), 0  EXIT,
    1  EXIT,
  WHEN EX1 EQ PINF,
    WHEN POSITIVE (EX2:SIGN(EX2)), PINF  EXIT,
    WHEN NEGATIVE(EX2), PZERO  EXIT,
    1  EXIT,
  WHEN EX1 EQ PZERO,
    WHEN POSITIVE (EX2:SIGN(EX2)), PZERO  EXIT,
    WHEN NEGATIVE(EX2), PINF  EXIT,
    ?  EXIT,
  WHEN EX1 EQ MZERO,
    WHEN POSITIVE(EX1:SIGN(EX2)),
      WHEN (EX2:ODDEVEN(EX2)) EQ 'E, PZERO  EXIT,
      WHEN EX2 EQ 'O, MZERO  EXIT,
      0  EXIT,
    WHEN NEGATIVE(EX1),
      WHEN (EX2:ODDEVEN(EX2)) EQ 'E, PINF  EXIT,
      WHEN EX2 EQ 'O, MINF  EXIT,
      CINF  EXIT,
    ?  EXIT,
  WHEN EX1 EQ MINF,
    WHEN POSITIVE (EX1:SIGN(EX2)),
      WHEN (EX2:ODDEVEN(EX2)) EQ 'E, PINF  EXIT,
      WHEN EX2 EQ 'O,  MINF  EXIT,
      CINF  EXIT,
    WHEN NEGATIVE(EX1),
      WHEN (EX2:ODDEVEN(EX2)) EQ 'E, PZERO  EXIT,
      WHEN EX2 EQ 'O, MZERO  EXIT,
      0  EXIT,
    1  EXIT,
  WHEN ZERO(EX1),
    WHEN POSITIVE(EX1:SIGN(EX2)),
      WHEN ODDEVEN(EX2) EQ 'E, PZERO  EXIT,
      0  EXIT,
    WHEN NEGATIVE(EX1),
      WHEN ODDEVEN(EX2) EQ 'E, PINF  EXIT,
      CINF  EXIT,
    ?  EXIT,
  EX1^EX2,
ENDFUN $

PROPERTY LIM, !, FUNCTION (EX1),
  WHEN MEMBER (EX1:LIM(EX1,#LIM), '(? PZERO PINF)), EX1  EXIT,
  WHEN EX1 EQ MINF OR EX1 EQ MZERO, ?  EXIT,
  EX1 !,
ENDFUN $

PROPERTY LIM, LOG, FUNCTION (EX1
  % Local: % EX2),
  WHEN (EX1:LIM1(EX1,#LIM)) EQ PZERO, MINF  EXIT,
  WHEN EX1 EQ PINF, PINF  EXIT,
  WHEN MEMBER (EX1, '(CINF MZERO MINF)) OR ZERO(EX2:SIGN(EX1)),
      CINF  EXIT,
  WHEN NEGATIVE(EX2),  ?  EXIT,
  LN(EX1),
ENDFUN $

PROPERTY LIM, ASIN, FUNCTION (EX1),
  WHEN MEMBER (EX1:LIM1(EX1,#LIM), '(? PZERO MZERO)), EX1  EXIT,
  WHEN EX1 EQ PINF OR EX1 EQ MINF, ?  EXIT,
  ASIN(EX1),
ENDFUN $

PROPERTY LIM, ATAN, FUNCTION (EX1),
  WHEN (EX1:LIM1(EX1,#LIM)) EQ PINF,  #PI/2  EXIT,
  WHEN EX1 EQ MINF, -#PI/2  EXIT,
  WHEN EX1 EQ CINF, ?  EXIT,
  WHEN MEMBER (EX1, '(? PZERO MZERO)), EX1  EXIT,
  ATAN(EX1),
ENDFUN $

PROPERTY LIM, SIN, FUNCTION (EX1),
  WHEN MEMBER (EX1:LIM1(EX1,#LIM), '(? CINF PINF MINF)), ?  EXIT,
  WHEN MEMBER (EX1, '(PZERO, MZERO)), EX1  EXIT,
  SIN(EX1),
ENDFUN$

PROPERTY LIM, COS, FUNCTION (EX1),
  WHEN MEMBER (EX1:LIM1(EX1,#LIM), '(? CINF PINF MINF)), ?  EXIT,
  WHEN MEMBER (EX1, '(PZERO, MZERO)), 1  EXIT,
  COS(EX1),
ENDFUN $

RDS() $
